
\section{From raw data to technically correct data}
\label{sect:rawtoinput}
% Some ideas:
%
% - Character encoding issues
% - regels overslaan, gebruiken van readLines
% - Special values, and how are they stored (NA, NULL,...)
% - Datatypen en conversie, yaml(?)
% - labels van categoriale variabelen
% - spelfouten in tekstvariabelen, normaliseren
%

\subsection{Reading data into R}

\subsubsection{\code{read.table} and its cousins}


\begin{tip}{Best practice}
Whenever you need to read data from a foreign file format, like a spreadsheet or
commercial statistical software, make that software responsible for exporting the 
data to an open format that can be read by \R{}.
\end{tip}


\subsubsection{Reading \code{XML} files}

\subsection{Type conversion}
In \R{}'s built-in help files, converting a variable from one type to another
is called \emph{coercion}. The reader is probably familiar with \R{}'s basic
coercion functions, but as a reference they are listed here.
\begin{center}
\begin{tabular}{ll}
  \code{as.numeric}     & \code{as.logical}\\
  \code{as.integer}     & \code{as.factor} \\
  \code{as.character}   & \code{as.ordered} 
\end{tabular}
\end{center}
Each of these functions takes an \R{} object and tries to convert it to the
class specified behind the ``\code{as.}''.

Below, we give a some background by delving a little into \R{}'s typing and
storage system and explain, amongst others, the difference between \R{}
\emph{types} and \emph{classes}. After that we discuss time and date
conversion.

\subsubsection{Introduction to \R{}'s typing system}
Everything in \R{} is an object\cite{chambers:2008}. An object is a container
of data with a \emph{class} label describing that data. Moreover, objects can
be created, destroyed or overwritten on-the-fly by the user.

The function \code{class} returns the class label of an \R{} object.
<<>>=
class(c('abc','def'))
class(1:10)
class(c(pi,exp(1)))
@
The above example demonstrates that not only basic data, but also more complex
structures like functions are also objects endowed with a class label.
%
\begin{tip}{Tip}
Here's a quick way to retrieve the classes of all columns in a \code{data.frame} called \code{dat}.
<<eval=FALSE>>=
sapply(dat,class)
@
\vspace{-1cm}
\end{tip}

For the user of \R{} these class labels should be enough to handle \R{} objects
in \R{} scripts. Under the hood, the basic \R{} objects are stored as \C{}
structures as \C{} is language in which \R{} itself has been written. The type
of \C{} structure that is used to store a basic type can be found with the
\code{typeof} function. Compare the results below with those in the previous
code snippet.
<<>>=
typeof(c('abc','def'))
typeof(1:10)
typeof(c(pi,exp(1)))
@
Note that the type of an \R{} object of class \code{numeric} is \code{double}.
The term \code{double} refers to \code{double precision}, which is a standard
way for lower-level computer languages such as \C{} to store approximations of real numers. 

Summarizing, one can regard the \emph{class} of an object the object's type from
the user's point of view while the \emph{type} of an object is the way \R{} looks
at the object.

Confusingly, \R{} objects also have a \emph{mode} (and \emph{storage.mode})
which can be retrieved or set using functions of the same name. Both
\code{mode} and \code{storage.mode} differ slightly from \code{typeof}, and are
only there for backwards compatibility with \R{}'s precursor language:
\code{S}. We therefore advise the user to avoid using these functions to
retrieve or modify an object's type. 




\subsubsection{Converting dates}
The base \R{} installation has three types of objects to store a time instance
\code{Date}, \code{POSIXlt} and \code{POSIXct}. The \code{Date} object
can only be used to store dates, the other two store date and/or time. Here, we
focus on converting text to \code{POSIXct} objects since this is probably the
most portable way to store such information.

Under the hood, a \code{POSIXct} object stores the number of seconds that have
passed since January 1, 1970 $00:00:00$. This makes it possible to compute
durations by simply subtracting two \code{POSIXct} objects. When a \code{POSIXct}
object is printed, \code{R} shows it in a human-readable calander format. For example,
the command \code{Sys.time} returns the system time provided by the operating system
in \code{POSIXct} format.
<<>>=
current_time <- Sys.time()
class(current_time)
current_time
@
Converting from a calender time to \code{POSIXct} and back is not entirely
trivial, since there are many idiosyncracies to handle in calander systems like
leap days, leap seconds, daylight saving times, time zones and so on.
%
Converting from text to \code{POSIXct} is further complicated by the many
textual conventions of time/date denotation. For example, both \code{28
September 1976} and \code{1976/09/28} both indicate the same day of the same
year. Moreover, the name of the month (or weekday) is language-dependent. In
this section we will not go into problems caused by leap days and seconds but
we will limit ourselves to converting the textual representation of a date to a
\code{POSIXct} object.

The \code{lubridate} package\cite{grolemund:2011} contains a number of
functions facilitating the conversion of text to \code{POSIXct} dates.
%
<<message=FALSE>>=
library(lubridate)
dates <- c("15/02/2013","15 Feb  13")
dmy(dates)
@
Here, the function \code{dmy} assumes that dates are denoted in the order
day-month-year and tries to extract valid dates. There are similar functions
for all permutations of \code{d}, \code{m} and \code{y}. Explicitly, all of the
following functions exist.
\begin{center}
\begin{tabular}{ccc}
\code{dmy} & \code{myd} &\code{ydm}\\
\code{mdy} & \code{dym} &\code{ymd}\\
\end{tabular}
\end{center}
So once it is known in what order days, months and years are denoted,
extraction is very easy. 

\begin{tip}{Note}
Years, indicated with two numbers are always interpreted as years in the 20'th century.
<<>>=
dmy("01 01 13")
@
\vspace{-1cm}
\end{tip}


It should be noted that \code{lubridate} (as well as \R{}'s base functionality) is
only capable of converting certain standard notations. For example, the following
notation does not convert.
<<>>=
dmy("15 Febr. 2013")
@
The standard notations that can be recognised by \R{}, either using \code{lubridate}
or \R{}'s builtin functionality are shown in Table \ref{tab:dateformats}.
%
\begin{table}
\begin{threeparttable}
  \caption{Day, month and year formats recognized by \R{}.}
  \label{tab:dateformats}
  \begin{tabular}{lll}
    \hline
    Code       & description\cite{}                             & Example  \\
    \hline
    \code{\%a} & Abbreviated weekday name in the current locale.& \code{Mon}  \\
    \code{\%A} & Full weekday name in the current locale.       & \code{Monday}\\
    \code{\%b} & Abbreviated month name in the current locale.  & \code{Sep} \\
    \code{\%B} & Full month name in the current locale.         & \code{September}\\
    \code{\%d} & Day of the month as decimal number (01-31).    & \code{28} \\
    \code{\%y} & Year without century (00-99)                   & \code{13}\\
    \code{\%Y} & Year including century.                        & \code{2013}\\
    \hline
  \end{tabular}
\end{threeparttable}
\end{table}
%
%
Here, the names of (abbreviated) week or month names that are sought for in the
text depend on the locale settings of the machine that is running \R{}. For example,
on a PC running under a Dutch locale, ``\code{maandag}'' will be recognized as the
first day of the week while in English locales ``\code{Monday}'' will be recognized. If
the machine running \R{} has multiple locales installed you may add the argument
\code{locale} to one of the \code{dmy}-like functions.
<<>>=

@






\subsection{Recoding strings}
\label{sect:stringnormalisation}
Character data can be notoriously hard to process. For example, consider the
following excerpt of a data set with a \code{gender} variable.
<<echo=2>>=
data.frame(gender=c("M","male ","Female","fem."))
@
If this would be treated as a factor variable without any preprocessing,
obviously four, not two classes would be stored. The job at hand is therefore
to automatically recognize from the above data whether each elements pertains
to \code{male} or \code{female}. In statistical contexts, classifying such
``messy'' text strings into a number of fixed categories is often referred to
as \emph{coding}.

Below we discuss two complementary approaches to string coding: \emph{string
normalisation} and \emph{approximate text matching}. In particular, the
following topics are discussed.
\begin{itemize}[itemsep=0pt]
\item Remove prepending or trailing white spaces.
\item Pad strings to a certain width.
\item Transform to upper/lower case.
\item Search for strings containing simple patterns (substrings).
\item Simple approximate matching procedures based on string distances.
\end{itemize}


\subsubsection{String normalisation}
%
String normalisation techniques are aimed at transforming a variety of strings
to a (possibly) smaller set of string values which are more easily processed.
By default, \R{} comes with extensive string manipulation functionality that is
based on the two basic string operations: \emph{finding} a pattern in a string
and \emph{replacing} one patterns with another. We will deal with \R{}'s
generic functions below but start by pointing out some common string cleaning
operations.
  
The \code{stringr} package\cite{wickham:2009} offers a number of functions that
make a some string manipulation tasks a lot easier. For example, extra white
spaces at the beginning or end of a string can be removed using
\code{str\_trim}.
<<>>=
library(stringr)
str_trim("  hello world ")
str_trim("  hello world ",side="left")
str_trim("  hello world ",side="right")
@
Conversely, strings can be padded with spaces or other characters with \code{str\_pad} to
a certain width. For example, numerical codes are often represented with prepending zeros.
<<>>=
str_pad(112,width=6,side='left', pad=0)
@
Both \code{str\_trim} and \code{str\_pad} accept a \code{side} argument to indicate wether
trimming or padding should occur at the beginning (\code{left}), end (\code{right}) or both
sides of the string. 

Converting strings to complete upper or lower case can be done with \R{}'s built-in
\code{toupper} and \code{tolower} functions.
<<>>=
toupper("Hello world")
tolower("Hello World")
@
We will return to string normalisation in the Section \ref{sect:encoding}.

\subsubsection{Approximate string matching}
There are two forms of string matching. The first consists of determining
whether a (range of) substring(s) occurs within another string. In this case
one needs to specify a range of substrings (called a \emph{pattern}) to search
for in another string. In the second form one defines a distance metric between
strings that measures how ``different'' two strings are.  Below we will discuss
a short introduction to pattern matching and string distances with \R{}.


There are several pattern matching functions that come with base \R{}. The most
used are probably \code{grep} and \code{grepl}. Both functions take a pattern
and a \code{character} vector as input. The output only differs in that
\code{grepl} returns a logical index, indicating which element of the input
\code{charater} vector contains the pattern, while \code{grep} returns a
numerical index. You may think of \code{grep(...)} as \code{which(grepl(...))}.

%
%
In the most simple case, the pattern to look for is a simple substring. For
example, using the data of the example on page
\pageref{sect:stringnormalisation}.
<<>>=
gender <- c("M","male ","Female","fem.")
grepl('m',gender)
grep('m',gender)
@
Note that the result is case sensitive: the capital \code{M} in the first
element of \code{gender} does not match the lower case \code{m}. There are
several ways to circumvent this case sensitivity.  Either by case normalisation
or by the optional argument \code{ignore.case}.
<<>>=
grepl('m',gender,ignore.case=TRUE)
grepl('m',tolower(gender))
@
Obviously, looking for the occurrence of \code{m} or \code{M} in the
\code{gender} vector does not allow us to determine which strings pertain to
\code{male} and which not. Preferably we would like to search for strings that
start with an \code{m} or \code{M}.  Fortunately, the search patterns that
\code{grep} accepts allow for such searches. The beginning of a string is
indicated with a caret (\code{\^}).
<<>>=
grepl('^m',gender,ignore.case=TRUE)
@
Indeed, the \code{grepl} function now finds only the first two elements of
\code{gender}.  The caret is an example of a so-called \emph{meta-character}.
That is, it does not indicate the caret itself but something else, namely the
beginning of a string. The search patterns that \code{grep}, \code{grepl} (and
\code{sub}
and \code{gsub}) understand have more of these meta-characters, namely: \verb". \ | ( ) [ {  ^ $ * + ?". 
If you need to search a string for any of these characters, you can use the
option \code{fixed=TRUE}.
<<>>=
grepl('^',gender,fixed=TRUE)
@
This will make \code{grepl} ignore any meta-characters in the search string.

Search patterns using meta-characters are called \emph{regular expressions}.
Regular expressions offer powerful and flexible ways to search (and alter)
text.  A discussion of regular expressions is beyond the scope of these lecture
notes. However, a concise description of regular expressions allowed by \R{}'s
built-in string processing functions can be found by typing \code{?regex} at
the \R{} command line. The books by Fitzgerald\cite{fitzgerald:2012} or
Friedl\cite{friedl:2006} provide a thorough introduction to the subject of
regular expression. If you frequently have to deal with ``messy'' text
variables, learning to work with regular expressions is a worthwhile
investment. Moreover, since many popular programming languages support some
dialect of regexps, it is an investment that could pay off several times.

We now turn our attention to the second method of approximate matching, namely
string distances.  A string distance is an algorithm or equation that indicates
how much two strings differ from eachother.  An important distance measure is
implemented by the \R{}'s native \code{adist} function. This function counts
how many basic operations are needed to turn one string into another. These
operations include insertion, deletion or substitution of a single
character\cite{levenshtein:1966}.  For example
<<>>=
adist("abc","bac")
@
The result equals two since turning \code{"abc"} into \code{"bac"} involves two
character substitutions. Using \code{adist}, we can compare fuzzy text strings
to a list of known codes. For example:
<<>>=
codes <- c('male','female')
D <- adist(gender,codes)
colnames(D) <- codes
rownames(D) <- gender
D
@
Here, \code{adist} returns the distance matrix between our vector of fixed
codes and the input data. For readability we added row- and column names
accordingly. Now, to find out which code matches best with our raw data, we
need to find the index of the smallest distance for each row of \code{D}. This
can be done as follows.
<<>>=
i <- apply(D,1,which.min)
data.frame(
  rawtext = gender,
  coded   = codes[i]
)
@
We use \code{apply} to apply \code{which.min} to every row of \code{D}. Note
that in the case of multiple minima, the first match will be returned.

Finally, we mention two more functions based on string distances. First, the
\R{}-builting function \code{agrep} is similar to grep, but it allows one to
specify a maximum Levenshtein distance between the input pattern and the found
substring. 

Secondly, the functions \code{stringdist} and \code{stringdistmatrix} of the
\code{stringdist} package\cite{loo:2013} offer an interfaces to a variety of
string distance metrics. For example, \code{agrep} does not allow for character
transpositions, which is quite common in typing errors. Using the \emph{optimal
string alignment distance} (the default choice for \code{stringdist}) we get
<<message=FALSE>>=
library(stringdist)
stringdist("abc","bac")
@
The answer is now 1 (not 2), since the optimal string alignment distance allows
for transpositions of adjacent characters.









\subsection{Character encoding issues}
\label{sect:encoding}


\subsection*{Exercises}
\begin{exercise}
Type checking and classes

  \begin{subex}
    \item Use the \code{\%in\%} operator to check wether \emph{<something-something>} is either \code{numeric} or \code{integer}.
    \item Error messages in \R{} sometimes report the underlying \emph{type} of an object rather than the user-level \emph{class}.
          Derive from the following code and error message what the underlying type of an \R{} function is.
          <<>>=
          mean[1]
          @
    Confirm your answer using \code{typeof}.
\end{subex}
\end{exercise}
